(ns rp.util.string
  (:require [clojure.tools.reader.edn :as edn]
            [clojure.string :as str]
            [rp.util.map :as util-map]
            [rp.util.number :as util-number]))

;; Automatically added requires by core.typed
(require '[clojure.spec.alpha :as s])
;; Start: Generated by clojure.core.typed - DO NOT EDIT
(s/def :clojure.core.typed.unqualified-keys/y string?)
(s/def :clojure.core.typed.unqualified-keys/x (s/nilable string?))
(s/def
  ::XYMap
  (s/keys
    :opt-un
    [:clojure.core.typed.unqualified-keys/x
     :clojure.core.typed.unqualified-keys/y]))
(s/fdef
  bats-and-carets->maps
  :args
  (s/cat :ks (s/tuple #{:x} #{:y}) :s (s/nilable string?))
  :ret
  (s/coll-of ::XYMap :into vector?))
(s/fdef
  carets->map
  :args
  (s/cat :ks (s/tuple #{:x} #{:y}) :s (s/nilable string?))
  :ret
  ::XYMap)
(s/fdef
  lower-case
  :args
  (s/cat :s (s/nilable string?))
  :ret
  (s/nilable string?))
(s/fdef
  make-parser
  :args
  (s/cat :re (partial instance? java.util.regex.Pattern))
  :ret
  ifn?)
(s/fdef
  non-blank
  :args
  (s/cat :s (s/nilable string?))
  :ret
  (s/nilable string?))
(s/fdef
  non-blank-string
  :args
  (s/cat :arg-0 (s/or :int? int? :string? string? :nil? nil?))
  :ret
  (s/nilable string?))
(s/fdef
  parse-boolean
  :args
  (s/cat :arg-0 (s/nilable string?))
  :ret
  (s/nilable boolean?))
(s/fdef
  parse-double
  :args
  (s/cat :s (s/nilable string?))
  :ret
  (s/nilable number?))
(s/fdef
  parse-double*
  :args
  (s/cat :arg-0 string?)
  :ret
  (s/nilable number?))
(s/fdef
  parse-long
  :args
  (s/cat :arg-0 (s/nilable string?))
  :ret
  (s/nilable int?))
(s/fdef
  parseable
  :args
  (s/cat
    :re
    (partial instance? java.util.regex.Pattern)
    :s
    (s/nilable string?))
  :ret
  (s/or :string? string? :nil? nil? :char? char?))
(s/fdef
  split-on-bat
  :args
  (s/cat :arg-0 (s/nilable string?))
  :ret
  (s/coll-of string? :into vector?))
(s/fdef
  split-on-bats-and-carets
  :args
  (s/cat :s (s/nilable string?))
  :ret
  (s/coll-of (s/coll-of string? :into vector?) :into vector?))
(s/fdef
  split-on-caret
  :args
  (s/cat :arg-0 (s/nilable string?))
  :ret
  (s/coll-of string? :into vector?))
(s/fdef
  split-on-re
  :args
  (s/cat
    :re
    (partial instance? java.util.regex.Pattern)
    :s
    (s/or :int? int? :string? string? :nil? nil?))
  :ret
  (s/coll-of string? :into vector?))
(s/fdef
  string
  :args
  (s/cat :s (s/or :int? int? :string? string? :nil? nil?))
  :ret
  (s/nilable string?))
;; End: Generated by clojure.core.typed - DO NOT EDIT
(def regexes
  {:long (re-pattern "([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?")
   :double (re-pattern "([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?")
   :boolean (re-pattern "(?i)true|false")
   :bat #"\^\+\^"
   :caret #"\^"
   :comma #","
   :dash #"-"
   :slash #"/"})

(declare non-blank-string)

(defn- parseable
  [re s]
  (when (non-blank-string s)
    (first (re-matches re s))))

(defn- make-parser
  [re]
  (fn [s]
    (when (parseable re s)
      (try
        (edn/read-string s)
        (catch Exception e)))))

(defn- string
  [s]
  (when (string? s)
    s))

(defn- non-blank
  [s]
  (when-not (str/blank? s)
    s))

(defn- lower-case
  [s]
  (when s
    (str/lower-case s)))

(def parse-double* (make-parser (:double regexes)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Public API
(def non-blank-string (comp non-blank string))
(def parse-long (make-parser (:long regexes)))
(def parse-boolean (comp (make-parser (:boolean regexes))
                         lower-case))

(defn parse-double
  [s]
  (some-> s
          parse-double*
          double))

(defn parse-big-decimal
  [s]
  (some-> s
          parse-double*
          bigdec))

(defn split-on-re
  "Useful for its check on blankness and interstitial whitespace trimming."
  [re s]
  (if (non-blank-string s)
    (mapv str/trim (str/split s re))
    []))

(def split-on-bat (partial split-on-re (:bat regexes)))
(def split-on-caret (partial split-on-re (:caret regexes)))
(def split-on-comma (partial split-on-re (:comma regexes)))
(def split-on-dash (partial split-on-re (:dash regexes)))
(def split-on-slash (partial split-on-re (:slash regexes)))

(defn split-on-bats-and-carets
  [s]
  (mapv split-on-caret (split-on-bat s)))

(defn carets->map
  [ks s]
  (->> s
       split-on-caret
       (map non-blank-string)
       (zipmap ks)
       util-map/remove-nils))

(defn bats-and-carets->maps
  [ks s]
  (mapv #(carets->map ks %) (split-on-bat s)))

(defn parse-bounding-box
  [s]
  (when (string? s)
    (let [[lng1 lat1 lng2 lat2 :as bounding-box] (mapv parse-double (split-on-comma s))]
      (when (and (util-number/longitude? lng1)
                 (util-number/latitude? lat1)
                 (util-number/longitude? lng2)
                 (util-number/latitude? lat2))
        bounding-box))))